angular.module('builder.styling')

.factory('css', ['$rootScope', 'classHelper', 'aivaSelect', 'undoRedo', function($rootScope, classHelper, aivaSelect, undoRedo) {

	var css = {
		sheet: null,
		editorCss: null,
		unsupportedRules: null,
		compile: compile,
		loadCss: loadCss,
		add: add,
		applyRule: applyRule,
		duplicateElementRules: duplicateElementRules,
		duplicateVariantRules: duplicateVariantRules,
		upgradeOldProjectRules: upgradeOldProjectRules
	};
	
	return css;

	/**
	 * Compile custom user css and css generated by the
	 * builder itself into a single formatted string.
	 *
	 * @return string
	 */
	function compile() {
		var compiledCss = '';

		if (!css.sheet){
			loadEditorStyleSheet();
		}

		if (css.sheet) {
			var activeRules = getActiveRules();
			var combinedRules = combineDupicateRules(activeRules);

			_.forEach(combinedRules, function(rule) {
				compiledCss += rule + '\n\n';
			});
		}

		if (css.unsupportedRules) {
			_.forEach(css.unsupportedRules, function(ruleObj) {
				var ruleText = ruleObj.selectorText + '{ ';

				_.forEach(ruleObj.declarations, function(declaration) {
					ruleText += declaration + '; ';
				});

				ruleText += '}';
				compiledCss += ruleText + '\n\n';
			});
		}

		loadCss(compiledCss); //update css.sheet 
		
		return compiledCss;
	}

	/**
	 * Load given css into iframe.
	 *
	 * @param  string cssString
	 * @return {void}
	 */
	function loadCss(cssString) {
		loadEditorStyleSheet();
		
		//clear current css
		css.editorCss.html('');

		if (cssString !== null) {
			//load given css
			css.editorCss.append("\n"+cssString); //this will only save rules the browser understands
		} else {
			css.editorCss.append('\n');
		}

		if (css.editorCss.length > 0) {
			css.sheet = css.editorCss[0].sheet; 
		}

		loadUnsupportedCss(cssString);
	}

	function loadUnsupportedCss(cssString) {
		//handle rules unsupported by the browser 
		if (cssString !== null && cssString.length > 0) {
			css.unsupportedRules = findUnsupportedRules(cssString);
		}
	}

	function findUnsupportedRules(cssString) {
		cssString = cssString.replace(/(\r\n|\n|\r)/gm,'');
		var rules = cssString.split('}');
		rules = _.filter(rules, function(rule) {
			return rule.length > 0;
		});
		rules = _.map(rules, function(rule){
			return rule + '}';
		});

		var savedRulesCssText = _.map(css.sheet.rules, function(rule) {
			return rule.cssText;
		});

		var unsupportedRules = [];

		_.forEach(rules, function(rule) {
			if (savedRulesCssText.indexOf(rule) === -1 && rule.indexOf('placeholder') > -1) {

				var splitRule = rule.split('{');
				var selectorText = splitRule[0];
				var decalarationsText = splitRule[1].split('}')[0].trim();
				var declarations = decalarationsText.split(/;/);

				var ruleObj = {
					selectorText: selectorText,
					declarations: []
				};

				_.forEach(declarations, function(declaration) {
					declaration = declaration.trim();

					if (declaration.length > 0) {
						ruleObj.declarations.push(declaration);
					}
				});

				unsupportedRules.push(ruleObj);
			}
		});

		return unsupportedRules;
	}

	function loadEditorStyleSheet() {
		css.editorCss = $rootScope.frameHead.find('#editor-css');

		if (css.editorCss.length > 0) {
			css.sheet = css.editorCss[0].sheet;
		} else {
			var styleElem = document.createElement('style');
			styleElem.setAttribute('id', 'editor-css');
			styleElem.appendChild(document.createTextNode(''));
			$rootScope.frameHead[0].appendChild(styleElem);

			css.editorCss = $(styleElem);
			css.sheet = styleElem.sheet;
		}
	}

	function generateUnsupportedRulesLink() {
		var styleSheetLink = document.createElement('link');
		styleSheetLink.id = 'unsupportedRules';
		styleSheetLink.rel = 'stylesheet';
		styleSheetLink.href = 'data:text/css;charset=UTF-8,';
		$rootScope.frameHead.append(styleSheetLink);

		return $(styleSheetLink);
	}

	function add(selector, style, value, oldValue, selectedVariantClass, noEvent) {
		var hoverSelector, origValue;
		var selectedElements = aivaSelect.getSelected();

		if (!css.sheet) {
			loadEditorStyleSheet();
		}
		
		if (selector) { //only used for :hover styles
			css.applyRule(selector, style, value, oldValue, null, selectedVariantClass);
		} else if (selectedElements.length > 0) {
			var undoIds = aivaSelect.getSelectedIds();
			var undoData = []; //array of objects for css changes

			var textStyles = ['text-decoration', 'font-style', 'font-weight', 'text-align', 'color', 'font-size'];
			var placeholderElemTypes = ['textInput', 'emailInput', 'passwordInput'];
			var triangleBackgroundStyles = [ //cant set background-color property on triangles 
				{
					elemClass: 'triangle-up',
					backgroundColorStyle: 'border-bottom-color',
				},
				{
					elemClass: 'triangle-down',
					backgroundColorStyle: 'border-top-color',
				},
				{
					elemClass: 'triangle-left',
					backgroundColorStyle: 'border-right-color',
				},
				{
					elemClass: 'triangle-right',
					backgroundColorStyle: 'border-left-color',
				},
				{
					elemClass: 'triangle-top-left',
					backgroundColorStyle: 'border-left-color',
				},
				{
					elemClass: 'triangle-top-right',
					backgroundColorStyle: 'border-right-color',
				},
				{
					elemClass: 'triangle-bottom-left',
					backgroundColorStyle: 'border-left-color',
				},
				{
					elemClass: 'triangle-bottom-right',
					backgroundColorStyle: 'border-right-color',
				}
			];

			_.forEach(selectedElements, function(element) { // apply css to all selected items
				var wrappedElement = $(element);
				var elementType = element.getAttribute('data-name');
				var elementId = element.getAttribute('data-id');
				selector = '.cta .' + elementId;	

				if (placeholderElemTypes.indexOf(elementType) > -1 && textStyles.indexOf(style) > -1) {

					if (style === 'font-size') {
						value += 'px';
					}

					var browserPostFixes = ['::-webkit-input-placeholder', ':-moz-placeholder', '::-moz-placeholder', ':-ms-input-placeholder'];
					
					_.forEach(browserPostFixes, function(postFix) { //we need a seperate rule for each browser for placeholder styles
						var placeholderSelector = selector + postFix;

						var oldStyleValue = getStyleValue(placeholderSelector, style);
						// var undoObj = {};
						// undoObj.oldStyleValue = oldStyleValue;
						// undoObj.id = elementId;
						// undoObj.style = style;
						// undoObj.newStyleValue = value;

						//undoData.push(undoObj);
						css.applyRule(placeholderSelector, style, value, oldValue, hoverSelector, selectedVariantClass);
					});
				} 
				
				if (wrappedElement.is('[class*="triangle-"') && (style === 'background' || style === 'background-color')) {
					
					_.forEach(triangleBackgroundStyles, function(triangleBackgroundStyle) {
						if (wrappedElement.hasClass(triangleBackgroundStyle.elemClass)) {
							style = triangleBackgroundStyle.backgroundColorStyle;
							return false;
						}
					});
				}
				
				
				var oldStyleValue = getStyleValue(selector, style);
				var undoObj = {};
				undoObj.oldStyleValue = oldStyleValue;
				undoObj.id = elementId;
				undoObj.style = style;
				undoObj.newStyleValue = value;

				if (hoverStyleRequired()) { 
					hoverSelector = selector + ":hover, " + selector + ":focus, " + selector + ":active";
					undoObj.updateHoverColor = true;
				}

				undoData.push(undoObj);
				css.applyRule(selector, style, value, oldValue, hoverSelector, selectedVariantClass);	
				
			});

			undoRedo.addToUndo('styleChange', selectedVariantClass, undoIds, undoData);
			
		} else if ($rootScope.ctaBaseOpen) {
			var activeCtaBase = $rootScope.frameBody.find('.' + selectedVariantClass);

			selector = '.' + activeCtaBase.attr('data-id');
			css.applyRule(selector, style, value, oldValue, null, selectedVariantClass);
		}
	}
	
	function applyRule(selector, style, value, oldValue, hoverSelector, selectedVariantClass) {
		var rule = style + ':' + value;
		var index = css.sheet.cssRules.length -1;

		for (var i = index; i >= 0; i--) {
			var existingStyle = css.sheet.cssRules[i];
			if (existingStyle.selectorText == selector) {
				rule = existingStyle.style.cssText + rule;
				css.sheet.deleteRule(i);
				index = i;
			}
		}

		if (index == -1) {
			index = 0;
		}

		try {
			if (css.sheet.insertRule) {
				css.sheet.insertRule(selector + '{' + rule + '}', index);
			} else {
				css.sheet.addRule(selector, rule, index);
			}
		} catch (e) { //chrome will throw a DomException when you try to add Mozilla or IE specific placeholder rules
			if (selector.indexOf('placeholder') > -1) {
				addNonStandardRule(selector, rule, index);
			}
		}

		$rootScope.$broadcast('builder.css.changed');
		
		if (hoverSelector) {
			var darkenedColor = tinycolor(value).darken().toString();
			css.add(hoverSelector, style, darkenedColor, oldValue, null);
		}
	}

	function addNonStandardRule(selector, rule, index) {
		var newRuleObj;

		if (!css.unsupportedRules || css.unsupportedRules.length === 0) { 
			newRuleObj = {
				selectorText: selector,
				declarations: [rule]
			};

			css.unsupportedRules = [];
			css.unsupportedRules.push(newRuleObj);
		} else {

			var foundExistingRule = false;

			_.forEach(css.unsupportedRules, function(ruleObj) {
				if (ruleObj.selectorText == selector) {
					foundExistingRule = true;

					var replacedDeclaration = false;
					_.forEach(ruleObj.declarations, function(declaration, index) {
						var propName = declaration.split(':')[0];

						if (rule.indexOf(propName) > -1) { //replace it
							ruleObj.declarations[index] = rule;
							replacedDeclaration = true;
						}
					});

					if (!replacedDeclaration) {
						ruleObj.declarations.push(rule);
					}
				}
			});

			if (!foundExistingRule) {
				newRuleObj = {
					selectorText: selector,
					declarations: [rule]
				};
				css.unsupportedRules.push(newRuleObj);
			} 
		}
	}

	function duplicateElementRules(oldElementId, newElementId) {
		if (!css.sheet) {
			loadEditorStyleSheet();
		}

		if (css.sheet) {
			var updatedRules = [];
			_.forEach(css.sheet.cssRules, function(rule) {
				if (rule.cssText.indexOf(oldElementId) > 0) {
					var updatedRule = rule.cssText.replace(new RegExp(oldElementId, 'g'), newElementId);
					updatedRule = updatedRule.replace(/.cta-\w+/g, '.cta'); //if rule has old style cta-lg or cta-sm,  replace it with .cta

					if (updatedRule.indexOf('.cta') == -1) {
						updatedRule = '.cta ' + updatedRule;
					}

					updatedRules.push(updatedRule);
				}
			});

			_.forEach(updatedRules, function(newRule) {
				css.sheet.insertRule(newRule, css.sheet.cssRules.length - 1);
			});
		}
	}

	function duplicateVariantRules(oldVariantClass, newVariantClass) {
		if (!css.sheet) {
			loadEditorStyleSheet();
		}

		if (css.sheet) {
			var updatedRules = [];

			_.forEach(css.sheet.cssRules, function(rule) {
				if (rule.cssText.indexOf(oldVariantClass) > 0) {
					var updatedRule = rule.cssText.replace(new RegExp(oldVariantClass, 'g'), newVariantClass);
					updatedRules.push(updatedRule);
				}
			});

			_.forEach(updatedRules, function(newRule) {
				css.sheet.insertRule(newRule, css.sheet.cssRules.length - 1);
			});
		}
	}

	function upgradeOldProjectRules(oldElementId, newElementId, oldCtaClass) {
		//old projects may have elements on desktop and mobile with the same 'id'. We update the id, then call this function to fix style rules
		if (!css.sheet) {
			loadEditorStyleSheet();
		}

		if (css.sheet) {
			var updatedRules = [];
			_.forEach(css.sheet.cssRules, function(rule) {
				if (rule.cssText.indexOf(oldElementId) > -1 && rule.cssText.indexOf(oldCtaClass) > -1) {
					var updatedRule = rule.cssText.replace(new RegExp(oldElementId, 'g'), newElementId);
					updatedRule = updatedRule.replace(oldCtaClass, 'cta');

					updatedRules.push(updatedRule);
				}
			});

			_.forEach(updatedRules, function(newRule) {
				css.sheet.insertRule(newRule, css.sheet.cssRules.length - 1);
			});
		}
	}

	function getStyleValue(selector, style) {
		var foundValue;

		if (!css.sheet) {
			loadEditorStyleSheet();
		} 

		if (css.sheet) {
			var foundRule = _.findLast(css.sheet.cssRules, function(rule) {
				return rule.selectorText == selector;
			});

			if (foundRule) {
				var oldStyleVal = foundRule.style[style];
				foundValue = oldStyleVal && oldStyleVal.length > 0 ? oldStyleVal : null;
			}
		}

		return foundValue;
	}

	function hoverStyleRequired(style, elementType) {
		return (style === 'background' && elementType === 'button');
	}

	function getActiveRules() { //active rule is one that has an element on the cta
		var aivaElementSelectors = aivaSelect.getAllAivaElementselectors();
		var activeRules = [];

		_.forEach(css.sheet.rules, function(rule) {

			var ruleActive = false;

			_.forEach(aivaElementSelectors, function(selector) {
				if ((rule.selectorText.indexOf(selector.id) > -1 && rule.selectorText.indexOf(selector.cta) > -1 || 
						rule.selectorText.indexOf(' ') == -1)) { //if no space in selectortext, assume cta base rule...
					ruleActive = true;
				}
			});

			if (ruleActive) {
				activeRules.push(rule);
			}
		});

		return activeRules;
	}

	function combineDupicateRules(rules) {
		var foundStyleObjs = [];
		var ruleTextArr = [];
		
		_.forEach(rules, function(rule, index) {
			ruleTextArr.push(rule.cssText);

			var seperatedCssProps = seperateCssProps(rule); 

			if (foundStyleObjs.length > 0) {

				var ruleAddedPreviously = _.find(foundStyleObjs, function(obj) {
					return obj.selectorText == rule.selectorText; 
				});

				if (ruleAddedPreviously) {
					ruleAddedPreviously.foundAt.push(index);
					ruleAddedPreviously.cssTextArr.push(rule.style.cssText);
					ruleAddedPreviously.cssProps = ruleAddedPreviously.cssProps.concat(seperatedCssProps);
				} else {
					foundStyleObjs.push({ 
						selectorText: rule.selectorText,
						cssTextArr: [rule.style.cssText],
						foundAt: [index],
						cssProps: seperatedCssProps
					});
				}

			} else {
				foundStyleObjs.push({
					selectorText: rule.selectorText,
					cssTextArr: [rule.style.cssText],
					foundAt: [index],
					cssProps: seperatedCssProps
				});
			}
		});

		var duplicates = _.filter(foundStyleObjs, function(obj) { //filter out only the objects that have the same rule occur more than once
			return obj.cssTextArr.length > 1;
		});


		var indexesToPull = [];
		var newCombinedRules = [];

		_.forEach(duplicates, function(duplicate) { //iterate through each object we found that contains duplicate rules 

			var uniquecssProps = _.uniqBy(_.reverse(duplicate.cssProps), function(prop) {
				return prop;
			});	

			var index = duplicate.cssTextArr.length - 1;
			for (var i = index; i >= 0; i--) {
				var ruleIndex = duplicate.foundAt[i];
				indexesToPull.push(ruleIndex);
			}

			var newRule = duplicate.selectorText + '{';

			_.forEach(_.reverse(uniquecssProps), function(prop) {
				newRule += prop;
			});

			newRule += '}';

			newCombinedRules.push(newRule);
		});

		indexesToPull = indexesToPull.sort(function(a, b) {
			return b - a;
		});

		_.forEach(indexesToPull, function(index) {
			_.pullAt(ruleTextArr, index);
		});

		_.forEach(newCombinedRules, function(rule) {
			ruleTextArr.push(rule);
		});	

		return ruleTextArr;
	}

	function seperateCssProps(rule) {
		var propsArray = [];
		var valuesText = rule.cssText.split('{')[1].slice(0, -1);
		var values = valuesText.split(new RegExp(';', 'g'));

		_.forEach(values, function(val) {
			val = val.trim();

			if (val.length > 0) {
				propsArray.push(val + ';');
			}
		});

		return propsArray;
	}
}]);